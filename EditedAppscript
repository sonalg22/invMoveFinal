//This function creates the UI tab to run these functions from the sheet
function onOpen() {
  var ui = SpreadsheetApp.getUi();
  ui.createMenu('Move Inventory')
      .addItem('Check for Subs', 'lookForSubs')
      //.addItem('Filter Inventory', 'filterInventory')
      .addItem('Update Inventory Quantities', 'inventoryCheck')
     // .addItem('Clean Inventory', 'formatMasterData')
      .addItem('Send to Template', 'moveInventory')
      .addItem('Download Template','downloadTemplate')
      .addToUi();

}

/** On open, remove old mo data from master data tab */
function compareAndCleanMasterData() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var masterDataSheet = spreadsheet.getSheetByName('master_data');
  var sheets = spreadsheet.getSheets();

  // Sheets to skip
  var sheetsToSkip = ['master_data', 'import_template_ab', 'updated_quantities'];

  // Collect unique MO numbers from Master Data
  var masterDataRange = masterDataSheet.getDataRange();
  var masterDataValues = masterDataRange.getValues();
  var masterMoNumbers = new Set();

  for (var i = 1; i < masterDataValues.length; i++) { // Assuming the first row is the header
    var moNumber = masterDataValues[i][0];
    if (moNumber) {
      masterMoNumbers.add(moNumber.toString());
    }
  }

  // Collect MO numbers from MK sheets
  var mkMoNumbers = new Set();
  for (var i = 0; i < sheets.length; i++) {
    var mkSheet = sheets[i];
    var mkSheetName = mkSheet.getName();

    // Skip sheets with specific names
    if (sheetsToSkip.includes(mkSheetName.toLowerCase())) {
      continue;
    }

    var range = mkSheet.getDataRange();
    var values = range.getValues();

    for (var j = 1; j < values.length; j++) { // Assuming the first row is the header
      var moNumber = values[j][0];
      if (moNumber) {
        mkMoNumbers.add(moNumber.toString());
      }
    }
  }

  // Find and delete rows in Master Data that are not in MK sheets and not null
  var rowsToDelete = [];
  for (var i = 1; i < masterDataValues.length; i++) {
    var moNumber = masterDataValues[i][0] ? masterDataValues[i][0].toString() : null;
    if (moNumber && !mkMoNumbers.has(moNumber)) {
      rowsToDelete.push(i + 1); // Account for header row
    }
  }

  // Delete rows from bottom to top to avoid index shifting
  rowsToDelete.reverse().forEach(function(row) {
    masterDataSheet.deleteRow(row);
  });
}

/** On open, clear highlighting from master data tab */
function clearMasterDataFillColor() {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var masterDataSheet = spreadsheet.getSheetByName("master_data");

    if (masterDataSheet) {
        // Get the range to clear fill color
        var range = masterDataSheet.getDataRange();
        
        // Clear the fill color
        range.setBackground(null);
    }
}


/** Locking Cells for edit protection */
function cellLock(){
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = spreadsheet.getActiveSheet();

  // Check if the active sheet name starts with 'MK'
  if (sheet.getName().indexOf('MK') === 0) {
    // Get the last row with content in column A
    var finalRow = sheet.getLastRow();

    // Define the range to be protected (all rows in columns A to I)
    var range = sheet.getRange('A:G' + finalRow);

    // Protect the range
    var protection = range.protect();

    // Set options for the protection
    protection.setDescription('Locked Range');
    protection.setWarningOnly(true); // Allow users to edit with warning
  }

}


/** Identify an MK sheet with boxes checked as the active sheet */
function findActiveSheetWithCheckedCheckbox() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheets = spreadsheet.getSheets();

  for (var i = 0; i < sheets.length; i++) {
    var sheet = sheets[i];

    // Check if the sheet name starts with "MK"
    if (sheet.getName().indexOf("MK") === 0) {
      var lastRow = sheet.getLastRow();
      var checkboxColumn = 13; // Assuming checkboxes are in column 13 (M)

      //Logger.log("Checking sheet: " + sheet.getName());

      // Iterate through the rows to find checked checkboxes
      for (var row = 2; row <= lastRow; row++) {
        var checkboxCell = sheet.getRange(row, checkboxColumn);
        var checkboxValue = checkboxCell.getValue();

        // Check if the checkbox is checked
       //Logger.log("Row " + row + ", Checkbox Value: " + checkboxValue);

        if (checkboxValue === true) {
         Logger.log("Sheet name: " + sheet.getName());
          // Return the sheet object if a checked checkbox is found
          return sheet;
        }
      }
    }
  }
  // If no sheet with checked checkboxes is found, return null
  return null;
}

/** Conditionally highlight cells when staged for prod and used for prod don't match, set to on edit trigger*/
function productionMismatch(e) {
  var sheet = e.source.getActiveSheet();
  var range = e.range;

  // Check if the change occurred within columns J and K
  if (sheet.getName().indexOf("MK") === 0 && range.getColumn() >= 10 && range.getColumn() <= 11) {
    // Get values in columns J and K for the modified row
    var staged = sheet.getRange(range.getRow(), 10).getValue();
    var used = sheet.getRange(range.getRow(), 11).getValue();
    

    // Compare values in columns J and K
    if (staged === used) {
      // Clear background color if J is equal to K
      sheet.getRange(range.getRow(), 10, 1, 2).setBackground(null);
    } else {
      // Set background color to blue if J is not equal to K
      sheet.getRange(range.getRow(), 10, 1, 2).setBackground("#ADD8E6"); // Blue color
    }

    if (staged != "" && used != ""){
      var returned = (Number(staged) - Number(used))
      sheet.getRange(range.getRow(), 12).setValue(returned);
    }
  }
}


/** Generate the checkbox at the end of the row after data entry */
function generateCheckboxInRow() {
  try {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var sheets = spreadsheet.getSheets();

    for (var i = 0; i < sheets.length; i++) {
      var sheet = sheets[i];

      // Check if the sheet name starts with "MK"
      if (sheet.getName().indexOf("MK") === 0) {
        Logger.log("Processing sheet: " + sheet.getName());
        
        var activeRange = sheet.getActiveRange();
        if (activeRange) {
          var activeRow = activeRange.getRow();
          Logger.log("Active row: " + activeRow);

          // Only proceed if the active row is greater than 1
          if (activeRow > 1) {
            var checkboxCell = sheet.getRange(activeRow, 13, 1, 1); // Cell in 13th column of active row
            var checkboxValue = checkboxCell.getValue();
            Logger.log("Checkbox cell value: " + checkboxValue);

            // Check if the checkbox already exists
            if (checkboxValue !== "") {
              Logger.log("Checkbox already exists in row " + activeRow);
              continue;
            }

            // Generate a new checkbox
            var rule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
            checkboxCell.setDataValidation(rule);
            Logger.log("Checkbox created in row " + activeRow);
          } else {
            Logger.log("Active row is 1 or less, skipping");
          }
        } else {
          Logger.log("No active range found");
        }
      } else {
        Logger.log("Sheet name does not start with MK: " + sheet.getName());
      }
    }
  } catch (e) {
    Logger.log("Error: " + e.toString());
  }
}

/** Filter new inventory results */
function filterInventory() {
  Logger.log("searching inventory quantities");
  updatePartCounts()
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var inventorySheet = spreadsheet.getSheetByName('updated_quantities');
  var range = inventorySheet.getDataRange();
  var values = range.getValues();

  // Keep the header row
  var headerRow = values.shift();
  
  // Define your filtering criteria
  var filteredValues = values.filter(function(row) {
    // Filter rows where the value in column C starts with "Atom Banana" and doesn't contain "Dandee" or "Picking"
    return /^Atom Banana/.test(row[2]) && row[2].indexOf("Dandee") === -1 && row[2].indexOf("Picking") === -1 && row[2].indexOf("Prepared") === -1;
  });

  // Sort filtered values by a specific column (e.g., column B) in ascending order
  filteredValues.sort(function(a, b) {
    // Sort by the values in column B (index 1)
    return a[1] - b[1]; // Change this based on the data type of column B (e.g., string, number)

  });

  // Add back the header row
  filteredValues.unshift(headerRow);

  // Update the sheet with filtered and sorted values
  range.clearContent(); // Clear existing content
  inventorySheet.getRange(1, 1, filteredValues.length, filteredValues[0].length).setValues(filteredValues);

  // Set the format of column 'J' to 'text' to prevent scientific notation
  inventorySheet.getRange('J2:J').setNumberFormat('@STRING@');


  // Calculate the sum of 'on_hand' values for each 'part_number' and place the result in column L
  var totals = {};
  filteredValues.forEach(function(row) {
    var partNumber = row[0]; // Assuming 'part_number' is in column A (index 0)
    var onHand = row[3]; // Assuming 'on_hand' is in column D (index 3)

    // Initialize the total to 0 if it doesn't exist
    if (!totals[partNumber]) {
      totals[partNumber] = 0;
    }

    // Add 'on_hand' value to the total for the corresponding 'part_number'
    totals[partNumber] += onHand;
  });

  // Duplicate the total on hand values by part number
  var duplicatedTotals = [];
  filteredValues.forEach(function(row, index) {
    if (index === 0) {
      duplicatedTotals.push(['Total On Hand']); // Header for totals column
    } else {
      var partNumber = row[0]; // Assuming 'part_number' is in column A (index 0)
      duplicatedTotals.push([totals[partNumber]]); // Add the total on hand value for the corresponding part number
    }
  });

  // Write the duplicated totals to column L
  inventorySheet.getRange(1, 12, duplicatedTotals.length, 1).setValues(duplicatedTotals);

  // Add the column header for checkboxes
  inventorySheet.getRange('M1').setValue('Use as Sub');


  // Create checkboxes in column M
  var checkboxRange = inventorySheet.getRange(2, 13, filteredValues.length - 1, 1);
  var checkboxRule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
  checkboxRange.setDataValidation(checkboxRule);

  
  //Add a column header for vendor uom
  inventorySheet.getRange('N1').setValue('Vendor UOM');
  // Format the entire column N as a number
  inventorySheet.getRange('N2:N').setNumberFormat('0'); 
// Ensure all values in column 'J' are treated as text
  inventorySheet.getRange('J2:J' + inventorySheet.getLastRow()).setNumberFormat('@STRING@');

}

/** Identify parts that will likely need a sub */
function lookForSubs() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheets = spreadsheet.getSheets();

  for (var i = 0; i < sheets.length; i++) {
    var sheet = sheets[i];
    var sheetName = sheet.getName();

    if (sheetName.indexOf("MK") === 0) {
      var lastRow = sheet.getLastRow();
      var range = sheet.getRange(2, 1, lastRow - 1, 20); // Adjust the range to cover all relevant columns (assuming columns A to T)
      var values = range.getValues();
      var backgrounds = range.getBackgrounds(); // Get the current background colors

      for (var j = 0; j < values.length; j++) {
        var row = values[j];
        var pickPartNumber = row[2];
        var pickQty = parseInt(row[4]); // Column E (index 4)
        var totalOnHand = parseInt(row[18]); // Column S (index 18)

        if (pickQty > totalOnHand) {
          var rowNumber = j + 2; // Adjust for 0-based index and header row
          var rangeToHighlight = sheet.getRange(rowNumber, 1, 1, 20); // Range for the entire row
          rangeToHighlight.setBackground("#fb6f92"); }
        // } else if (pickQty < totalOnHand && backgrounds[j][0] == "#fb6f92") {
        //   var rowNumber = j + 2; // Adjust for 0-based index and header row
        //   var rangeToUnhighlight = sheet.getRange(rowNumber, 1, 1, 20); // Range for the entire row
        else if (pickQty <= totalOnHand) {
          rangeToUnhighlight.setBackground(null);
        }
      }
    }
  }
}

/** Entry Point */
function startInventoryCheck() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var inventorySheet = spreadsheet.getSheetByName('updated_quantities');
  var totalRows = inventorySheet.getLastRow() - 1; // Exclude header
  var chunkSize = 100;

  PropertiesService.getScriptProperties().setProperties({
    inventory_totalRows: totalRows.toString(),
    inventory_currentRow: "2", // Start from row 2
    inventory_chunkSize: chunkSize.toString()
  });

  clearOldMasterInventory(); // Prepare before chunks
  processInventoryChunk();
}

function deleteAllProcessInventoryChunkTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === 'processInventoryChunk') {
      ScriptApp.deleteTrigger(triggers[i]);
    }
  }
}

/** The new Inventory Comparison */
function processInventoryChunk() {
  const props = PropertiesService.getScriptProperties();
  const currentRow = parseInt(props.getProperty("inventory_currentRow"));
  const totalRows = parseInt(props.getProperty("inventory_totalRows"));
  const chunkSize = parseInt(props.getProperty("inventory_chunkSize"));

  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const inventorySheet = spreadsheet.getSheetByName("updated_quantities");
  const masterSheet = spreadsheet.getSheetByName("master_data");

  const endRow = Math.min(currentRow + chunkSize - 1, totalRows + 1);
  const inventoryData = inventorySheet.getRange(currentRow, 1, endRow - currentRow + 1, 15).getValues();
  const masterData = masterSheet.getRange(2, 1, masterSheet.getLastRow() - 1, 22).getValues();

  const latestByPart = {};
  const masterIndexMap = {};
  masterData.forEach((row, idx) => {
    const part = row[4];
    const key = part + "_" + row[2]; // part + lot
    masterIndexMap[key] = idx;

    if (part && !latestByPart[part]) {
      latestByPart[part] = {
        vendorUOM: row[8],
        pickQty: row[6],
        casesNeeded: row[9],
        casesRounded: row[10]
      };
    }
  });

  const seenUpdates = new Set();
  const inventoryUpdate = [];
  const conditionsArray = [];

  inventoryData.forEach(invRow => {
    const part = invRow[0];
    const lot = invRow[9];
    const qty = invRow[3];
    const location = invRow[2];
    const totalQty = invRow[11];
    const key = part + "_" + lot;
    const idx = masterIndexMap[key];

    if (idx !== undefined) {
      const row = masterData[idx];
      const mo = row[0];
      const masterLoc = row[1];
      const masterQty = row[20];
      let vendorUOM = row[8];
      const partCount = row[15];

      if (mo !== " " && (qty !== row[18] || location !== masterLoc || totalQty !== masterQty)) {
        row[18] = qty;
        row[1] = location;
        row[20] = totalQty;

        if (!vendorUOM && latestByPart[part]) {
          vendorUOM = latestByPart[part].vendorUOM;
          row[8] = vendorUOM;
        }

        if (latestByPart[part]) {
          row[6] = latestByPart[part].pickQty;
          row[9] = latestByPart[part].casesNeeded;
          row[10] = latestByPart[part].casesRounded;
        }

        const newQtyCase = (vendorUOM && qty) ? (qty / vendorUOM) : null;
        const newTotalCase = (vendorUOM && totalQty) ? (totalQty / vendorUOM) : null;
        row[19] = newQtyCase;
        row[21] = newTotalCase;

        const updateKey = `${mo}-${part}-${location}-${totalQty}`;
        if (!seenUpdates.has(updateKey)) {
          seenUpdates.add(updateKey);
          inventoryUpdate.push([
            mo, location, part, vendorUOM, partCount, qty, totalQty, newQtyCase, newTotalCase
          ]);
        }
      }
    } else {
      conditionsArray.push(invRow);
    }
  });

  if (conditionsArray.length > 0) {
    newInventory(conditionsArray, masterData);
  }

  try {
    masterSheet.getRange(2, 1, masterData.length, 22).setValues(masterData);
    Logger.log("Chunk master data updated.");
  } catch (e) {
    Logger.log("Error writing master sheet chunk: " + e.message);
  }

  // Append chunk updates to cache
  const cache = CacheService.getScriptCache();
  const cached = JSON.parse(cache.get("inventoryUpdateCache") || "[]");
  const combined = cached.concat(inventoryUpdate);
  cache.put("inventoryUpdateCache", JSON.stringify(combined), 1800); // 30 mins

  // Schedule next chunk or finalize
  if (endRow < totalRows + 1) {
    props.setProperty("inventory_currentRow", (endRow + 1).toString());
    deleteAllProcessInventoryChunkTriggers();
    ScriptApp.newTrigger("processInventoryChunk")
      .timeBased().after(2000).create();
  } else {
    Logger.log("All chunks processed. Calling finalizeInventoryCheck().");
    finalizeInventoryCheck();
  }

  finalizeInventoryCheck();
}




/** Inventory Comparison */
function inventoryCheck() {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var inventorySheet = spreadsheet.getSheetByName('updated_quantities');
    var masterDataSheet = spreadsheet.getSheetByName("master_data");
    var inventoryDataValues = inventorySheet.getRange(2, 1, inventorySheet.getLastRow() - 1, 15).getValues();
    var masterDataValues = masterDataSheet.getRange(2, 1, masterDataSheet.getLastRow() - 1, 22).getValues();
    var inventoryUpdate = [];
    var conditionsArray = [];

    // Clear old master inventory
    var oldInventory = clearOldMasterInventory();

    // Create a map for latest part data (for filling blanks)
    var latestByPart = {};
    masterDataValues.forEach(function(row) {
        var partNumber = row[4];
        if (partNumber && !latestByPart[partNumber]) {
            latestByPart[partNumber] = {
                vendorUOM: row[8],
                pickQty: row[6],
                casesNeeded: row[9],
                casesRounded: row[10]
            };
        }
    });

    // Create a fast lookup map for masterDataValues
    var masterIndexMap = {};
    masterDataValues.forEach((row, idx) => {
        var key = row[4] + "_" + row[2]; // partNumber + lotNumber
        masterIndexMap[key] = idx;
    });

    // To prevent duplicate entries
    var seenUpdates = new Set();

    // Loop through inventory
    inventoryDataValues.forEach(function(inventoryRow) {
        var inventoryPartNumber = inventoryRow[0];
        var inventoryLotNumber = inventoryRow[9];
        var inventoryQty = inventoryRow[3];
        var inventoryLocation = inventoryRow[2];
        var inventoryTotalQty = inventoryRow[11];

        var key = inventoryPartNumber + "_" + inventoryLotNumber;
        var masterRowIndex = masterIndexMap[key];

        if (masterRowIndex !== undefined) {
            var masterRow = masterDataValues[masterRowIndex];
            var masterMoNumber = masterRow[0];
            var masterLocation = masterRow[1];
            var masterTotalQty = masterRow[20];
            var masterVendorUOM = masterRow[8];
            var masterPartCount = masterRow[15];

            if (masterMoNumber !== " ") {
                if (inventoryQty !== masterRow[18] || inventoryLocation !== masterLocation || inventoryTotalQty !== masterTotalQty) {
                    // Update the master row with new inventory values
                    masterRow[18] = inventoryQty;
                    masterRow[1] = inventoryLocation;
                    masterRow[20] = inventoryTotalQty;

                    // Fill in vendorUOM and other details from known latest data
                    if (!masterVendorUOM && latestByPart[inventoryPartNumber]) {
                        masterVendorUOM = latestByPart[inventoryPartNumber].vendorUOM;
                        masterRow[8] = masterVendorUOM;
                    }

                    if (latestByPart[inventoryPartNumber]) {
                        masterRow[6] = latestByPart[inventoryPartNumber].pickQty;
                        masterRow[9] = latestByPart[inventoryPartNumber].casesNeeded;
                        masterRow[10] = latestByPart[inventoryPartNumber].casesRounded;
                    }

                    // Recalculate cases
                    var newQtyCase = (masterVendorUOM && inventoryQty) ? (inventoryQty / masterVendorUOM) : null;
                    var newTotalCase = (masterVendorUOM && inventoryTotalQty) ? (inventoryTotalQty / masterVendorUOM) : null;
                    masterRow[19] = newQtyCase;
                    masterRow[21] = newTotalCase;

                    // Generate a unique key to prevent duplicates
                    let updateKey = `${masterMoNumber}-${inventoryPartNumber}-${inventoryLocation}-${inventoryTotalQty}`;
                    if (!seenUpdates.has(updateKey)) {
                        seenUpdates.add(updateKey);
                        inventoryUpdate.push([
                            masterMoNumber,
                            inventoryLocation,
                            inventoryPartNumber,
                            masterVendorUOM,
                            masterPartCount,
                            inventoryQty,
                            inventoryTotalQty,
                            newQtyCase,
                            newTotalCase
                        ]);
                    }
                }
            }
        } else {
            // Not found in master, collect for new inventory row
            conditionsArray.push(inventoryRow);
        }
    });

    if (conditionsArray.length > 0) {
        newInventory(conditionsArray, masterDataValues); // Handles insertion of new rows
    }

    // Merge updated inventory
    inventoryUpdate = inventoryUpdate.concat(oldInventory);

    // Write updated data to the master sheet
    try {
      masterDataSheet.getRange(2, 1, masterDataValues.length, 22).setValues(masterDataValues);
      Logger.log("Master sheet updated.");
    } catch (e) {
      Logger.log("Error writing to master sheet: " + e.message);
    }

    // Post-update operations
    try {
      newPartCounts();
      Logger.log("newPartCounts complete.");
    } catch (e) {
      Logger.log("Error in newPartCounts: " + e.message);
    }

    Logger.log("Calling updateOnHand with " + inventoryUpdate.length + " entries.");
    if (Array.isArray(inventoryUpdate) && inventoryUpdate.length > 0) {
      Logger.log("Sample inventoryUpdate row: " + JSON.stringify(inventoryUpdate[0]));
      updateOnHand(inventoryUpdate);
    } else {


          Logger.log("inventoryUpdate type: " + typeof inventoryUpdate);
          Logger.log("Is Array: " + Array.isArray(inventoryUpdate));
          Logger.log("Length: " + (inventoryUpdate ? inventoryUpdate.length : "null"));
          Logger.log("First item: " + JSON.stringify(inventoryUpdate[0]));

      Logger.log("No inventory updates to process.");
    }  
   
    SpreadsheetApp.flush();

    try {
        formatMasterData();
    } catch (error) {
        Logger.log("Error in formatMasterData: " + error.message);
    }

   //SpreadsheetApp.getUi().alert("Inventory updated.");
}

/** Final inventory chunk processing */
function finalizeInventoryCheck() {
  Logger.log("Finalizing inventory check...");

  try {
    newPartCounts();
    Logger.log("newPartCounts complete.");
  } catch (e) {
    Logger.log("Error in newPartCounts: " + e.message);
  }

  try {
    var cache = CacheService.getScriptCache();
    var updates = JSON.parse(cache.get("inventoryUpdateCache") || "[]");
    if (updates.length > 0) {
      Logger.log("Calling updateOnHand with " + updates.length + " updates.");
      updateOnHand(updates);
    } else {
      Logger.log("No updates found in cache.");
    }
    cache.remove("inventoryUpdateCache");
  } catch (e) {
    Logger.log("Error in updateOnHand: " + e.message);
  }

  try {
    formatMasterData();
  } catch (e) {
    Logger.log("Error in formatMasterData: " + e.message);
  }

  //SpreadsheetApp.getUi().alert("Inventory updated.");
  PropertiesService.getScriptProperties().deleteAllProperties();
  
}




function createMasterDataMap(masterDataValues) {
    var masterDataMap = {};
    masterDataValues.forEach(function(row) {
        var moNumber = row[0];
        var partNumber = row[4];
        var lotNumber = row[2];
        var description = row[5];
        masterDataMap[partNumber + '-' + lotNumber + '-' + description] = row;
    });
    return masterDataMap;
}

function createInventoryDataMap(inventoryDataValues) {
    var inventoryDataMap = {};
    inventoryDataValues.forEach(function(inventoryRow) {
        var inventoryPartNumber = inventoryRow[0];
        var inventoryLotNumber = inventoryRow[9];
        inventoryDataMap[inventoryPartNumber + '-' + inventoryLotNumber] = true;
    });
    return inventoryDataMap;
}

function createInventoryPartNumberMap(inventoryDataValues) {
    var inventoryPartNumberMap = {};
    inventoryDataValues.forEach(function(inventoryRow) {
        var inventoryPartNumber = inventoryRow[0];
        var inventoryLotNumber = inventoryRow[9];
        if (!inventoryPartNumberMap[inventoryPartNumber]) {
            inventoryPartNumberMap[inventoryPartNumber] = [];
        }
        inventoryPartNumberMap[inventoryPartNumber].push(inventoryLotNumber);
    });
    return inventoryPartNumberMap;
}


/** Data in Master and not Inventory  */
function clearOldMasterInventory() {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var inventorySheet = spreadsheet.getSheetByName('updated_quantities');
    var masterDataSheet = spreadsheet.getSheetByName("master_data");
   
    var inventoryDataValues = inventorySheet.getRange(2, 1, inventorySheet.getLastRow() - 1, 12).getValues();
    var masterDataValues = masterDataSheet.getRange(2, 1, masterDataSheet.getLastRow() - 1, 22).getValues();
    var oldInventory = [];

    // Create an object to store inventory data by part number and lot number for quick access
    var inventoryDataMap = {};
    var inventoryPartNumberMap = {};

    inventoryDataValues.forEach(function(inventoryRow) {
        var inventoryPartNumber = inventoryRow[0];
        var inventoryLotNumber = inventoryRow[9];
        var key = inventoryPartNumber + '-' + inventoryLotNumber;

        // Store row in the map
        inventoryDataMap[key] = inventoryRow;

        // Store part numbers
        if (!inventoryPartNumberMap[inventoryPartNumber]) {
            inventoryPartNumberMap[inventoryPartNumber] = [];
        }
        inventoryPartNumberMap[inventoryPartNumber].push(inventoryLotNumber);
    });

    // Iterate through master data
    masterDataValues.forEach(function(row, index) {
        var masterPartNumber = row[4];
        var masterLotNumber = row[2];
        var key = masterPartNumber + '-' + masterLotNumber;

        // Check if the key exists in the inventory data map
        if (!inventoryDataMap[key]) {
            // Check if the part number exists in both tabs but lot number does not match
            if (inventoryPartNumberMap[masterPartNumber]) {
                var lotNumbers = inventoryPartNumberMap[masterPartNumber];
                if (!lotNumbers.includes(masterLotNumber)) {
                    // Update master data values
                    masterDataValues[index][18] = 0; // masterOnHandQty
                    masterDataValues[index][19] = 0; // masterCases
                    masterDataValues[index][20] = 0; // masterTotalQty
                    masterDataValues[index][21] = 0; // masterTotalCases

                    oldInventory.push([
                        row[0], // masterMoNumber
                        row[1], // masterLocation
                        masterPartNumber,
                        row[8], // masterVendorUOM
                        row[15], // masterPartCount
                        0, // masterOnHandQty
                        0, // masterTotalQty
                        0, // masterCases
                        0  // masterTotalCases
                    ]);

                    //Logger.log('Part Number: ' + masterPartNumber + ' Lot Number: ' + masterLotNumber + ' grouped into EOM counts');
                }
            } else {
                // Part number does not exist in inventory data at all
                // Update master data values
                masterDataValues[index][18] = 0; // masterOnHandQty
                masterDataValues[index][19] = 0; // masterCases
                masterDataValues[index][20] = 0; // masterTotalQty
                masterDataValues[index][21] = 0; // masterTotalCases

                oldInventory.push([
                    row[0], // masterMoNumber
                    row[1], // masterLocation
                    masterPartNumber,
                    row[8], // masterVendorUOM
                    row[15], // masterPartCount
                    0, // masterOnHandQty
                    0, // masterTotalQty
                    0, // masterCases
                    0  // masterTotalCases
                ]);

                Logger.log('Part Number: ' + masterPartNumber + ' Lot Number: ' + masterLotNumber + ' no longer in inventory');
            }
        }
    });

    // Batch update master data sheet with new values
    masterDataSheet.getRange(2, 1, masterDataValues.length, masterDataValues[0].length).setValues(masterDataValues);

    return oldInventory;
}


/** UPDATE NEW INVENTORY DATA IN MASTER DATA TAB */
function newPartCounts() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var masterDataSheet = spreadsheet.getSheetByName("master_data");
  var dataRange = masterDataSheet.getDataRange();
  var values = dataRange.getValues();

  var partCountMap = {}; // Track counts per partNumber

  for (var j = 1; j < values.length; j++) {
    var moNumber = values[j][0];
    var partNumber = values[j][4];
    var pickQty = values[j][6];
    var onHandQty = values[j][18];
    var totalOnHand = values[j][20];

    if (!partNumber) continue; // Skip if part number is missing

    // Initialize partCount if this is the first time we see this part
    if (!partCountMap[partNumber]) {
      partCountMap[partNumber] = 1;
    } else {
      partCountMap[partNumber]++;
    }

    // Assign part count
    values[j][15] = partCountMap[partNumber];

    // If moNumber is missing, we still want to carry forward some values from earlier entries
    if (!moNumber && j > 1 && values[j - 1][4] === partNumber) {
      Logger.log("No MO# â€” copying related values for part: " + partNumber);

      values[j][6] = values[j - 1][6];   // pickQty
      values[j][7] = values[j - 1][7];   // part UOM
      values[j][8] = values[j - 1][8];   // vendor UOM
      values[j][9] = values[j - 1][9];   // cases needed
      values[j][10] = values[j - 1][10]; // cases rounded

      var vendorUOM = values[j][8];
      var newCasesOnHand = (vendorUOM && onHandQty) ? (onHandQty / vendorUOM) : null;
      var newTotalCasesOnHand = (vendorUOM && totalOnHand) ? (totalOnHand / vendorUOM) : null;

      values[j][19] = newCasesOnHand;
      values[j][21] = newTotalCasesOnHand;
    }

    Logger.log("Set partCount " + values[j][15] + " for part: " + partNumber);

    // Highlight updated row
    var rangeToHighlight = masterDataSheet.getRange(j + 1, 1, 1, values[j].length);
    rangeToHighlight.setBackground("#fb6f92");
  }

  dataRange.setValues(values);
  Logger.log("Part counts updated across master_data.");
}


/** UPDATE ON HAND VALUES IN MK SHEETS */
function updateOnHand(inventoryUpdate) {
  if (!Array.isArray(inventoryUpdate) || inventoryUpdate.length === 0) {
    Logger.log("Invalid inventoryUpdate passed to updateOnHand.");

    Logger.log("inventoryUpdate type: " + typeof inventoryUpdate);
    Logger.log("Is Array: " + Array.isArray(inventoryUpdate));
    Logger.log("Length: " + (inventoryUpdate ? inventoryUpdate.length : "null"));
    Logger.log("First item: " + JSON.stringify(inventoryUpdate[0]));
    return;
  }

  Logger.log("Running updateOnHand with " + inventoryUpdate.length + " records.");

  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheets = spreadsheet.getSheets();
  var updateMap = {};

  // Build a map: { moNumber: [entries] }
  inventoryUpdate.forEach(entry => {
    var moNumber = entry[0];
    if (!updateMap[moNumber]) {
      updateMap[moNumber] = [];
    }
    updateMap[moNumber].push(entry);
  });

  sheets.forEach(sheet => {
  const sheetName = sheet.getName();
  if (["master_data", "import_template_ab", "updated_quantities"].includes(sheetName)) return;

  for (const moKey in updateMap) {
    if (!sheetName.startsWith(moKey)) continue;

    Logger.log("Processing sheet: " + sheetName + " for moKey: " + moKey);
    const range = sheet.getDataRange();
    const data = range.getValues();
    let updated = false;

    for (let rowIndex = 1; rowIndex < data.length; rowIndex++) {
      const row = data[rowIndex];
      const mkPartNumber = row[2];
      const mkPartCount = parseInt(row[13], 10);
      const mkUOM = row[5];

      for (const entry of updateMap[moKey]) {
        const [moNumber, location, partNumber, vendorUOM, partCount, onHandQty, totalQty, onHandCases, totalCases] = entry;
        if (partNumber !== mkPartNumber) continue;

        if (Number(partCount) === mkPartCount) {
          if (row[1] !== location) { row[1] = location; updated = true; }
          if (row[16] !== onHandQty) { row[16] = onHandQty; updated = true; }
          if (row[17] !== onHandCases) { row[17] = onHandCases; updated = true; }
          if (row[18] !== totalQty) { row[18] = totalQty; updated = true; }
          if (row[19] !== totalCases) { row[19] = totalCases; updated = true; }
        }

        if (!mkUOM && Number(partCount) === 1) {
          if (row[5] !== "") { row[5] = ""; updated = true; }
          if (row[6] !== vendorUOM) { row[6] = vendorUOM; updated = true; }
          if (row[16] !== onHandQty) { row[16] = onHandQty; updated = true; }
          if (row[17] !== onHandCases) { row[17] = onHandCases; updated = true; }
          if (row[18] !== totalQty) { row[18] = totalQty; updated = true; }
          if (row[19] !== totalCases) { row[19] = totalCases; updated = true; }
        }
      }
    }

    if (updated) {
      range.setValues(data); // Write all changes at once
    }
  }
  });

  Logger.log("Finished updateOnHand.");
  Browser.msgBox("Inventory has been updated.");
}





function newInventory(conditionsArray, masterDataValues) {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var inventorySheet = spreadsheet.getSheetByName('updated_quantities');
    var masterDataSheet = spreadsheet.getSheetByName("master_data");

    Logger.log('Adding new inventory rows based on unmatched part/lot combos.');

    // Create a lookup for latest values by part number
    var latestByPart = {};
    for (var i = 0; i < masterDataValues.length; i++) {
        var row = masterDataValues[i];
        var partNumber = row[4];
        if (partNumber && !(partNumber in latestByPart)) {
            latestByPart[partNumber] = {
                vendorUOM: row[8],         // Column I
                pickQty: row[6],           // Column G
                casesNeeded: row[9],       // Column J
                casesRounded: row[10]      // Column K
            };
        }
    }

    for (var i = 0; i < conditionsArray.length; i++) {
        var inventoryRow = conditionsArray[i];
        var partNumber = inventoryRow[0];
        var lotNumber = inventoryRow[9];
        var expiration = inventoryRow[10];
        var inventoryQty = inventoryRow[3];
        var partUOM = inventoryRow[4];
        var location = inventoryRow[2];
        var description = inventoryRow[1];
        var totalQty = inventoryRow[11];

        var latest = latestByPart[partNumber] || {};
        var vendorUOM = latest.vendorUOM || '';
        var pickQty = latest.pickQty || '';
        var casesNeeded = latest.casesNeeded || '';
        var casesRounded = latest.casesRounded || '';

        var qtyCase = (vendorUOM && inventoryQty) ? inventoryQty / vendorUOM : '';
        var totalCase = (vendorUOM && totalQty) ? totalQty / vendorUOM : '';

        // Collect MO numbers for the current part number from master data
        var moNumbers = [];
        for (var j = 0; j < masterDataValues.length; j++) {
            if (masterDataValues[j][4] === partNumber) {
                var mo = masterDataValues[j][0];
                if (moNumbers.indexOf(mo) === -1) {
                    moNumbers.push(mo);
                }
            }
        }

        var rowsToInsert = moNumbers.length ? moNumbers : [' '];

        rowsToInsert.forEach(function(mo) {
            var newRow = [
                mo,
                location,
                lotNumber,
                expiration,
                partNumber,
                description,
                pickQty,
                partUOM,
                vendorUOM,
                casesNeeded,
                casesRounded,
                '', '', '', '', '', '', '', 
                inventoryQty,
                qtyCase,
                totalQty,
                totalCase
            ];

            var lastRow = masterDataSheet.getLastRow() + 1;
            masterDataSheet.getRange(lastRow, 1, 1, newRow.length).setValues([newRow]);

            Logger.log("New row inserted for part: " + partNumber + ", MO: " + mo);
        });
    }
}





/** Updates part counts based on the master_data sheet */
function updatePartCounts() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var masterSheet = ss.getSheetByName("master_data");

  if (!masterSheet) {
    Logger.log("master_data sheet not found.");
    return;
  }

  // Get all sheets that start with "MK"
  var mkSheets = ss.getSheets().filter(sheet => sheet.getName().startsWith("MK"));

  if (mkSheets.length === 0) {
    Logger.log("No sheet starting with 'MK' found.");
    return;
  }

  // Sort sheets by name (assuming the sheet names contain dates in a format that sorts correctly)
  mkSheets.sort((a, b) => {
    var dateA = new Date(a.getName().split(" ")[1]); // Extract date from name (e.g., "MK 2054 3/24/2025")
    var dateB = new Date(b.getName().split(" ")[1]);
    return dateB - dateA; // Sort in descending order (most recent first)
  });

  // Log the selected MK sheet (most recent)
  var selectedMkSheet = mkSheets[0];
  Logger.log("Selected MK sheet: " + selectedMkSheet.getName());

  var masterData = masterSheet.getDataRange().getValues();
  var rowCount = masterData.length;

  // Create a map to store the largest part_count for each part_number
  var partCountMap = {};

  // Loop through master_data to find the largest part_count for each part_number
  for (var i = 1; i < rowCount; i++) { // Assuming first row is header
    var partNumber = masterData[i][4]; // Column E (zero-based index 4)
    var partCount = masterData[i][15]; 

    if (partNumber) { // Ensure partNumber exists
      var parsedPartCount = parseInt(partCount) || 0; // Convert to integer, default to 0 if NaN
      if (!(partNumber in partCountMap) || parsedPartCount > partCountMap[partNumber]) {
        partCountMap[partNumber] = parsedPartCount; // Store the largest part_count for this part_number
      }
    }
  }

  // Check if selectedMkSheet has rows of data
  var mkData = selectedMkSheet.getDataRange().getValues();
  if (mkData.length <= 1) {
    Logger.log("No data in selected MK sheet or it only contains the header.");
    return;
  }

  // Loop through the MK sheet rows and update the part_count for each corresponding part_number
  for (var j = 1; j < mkData.length; j++) { // Assuming first row is header
    var mkPartNumber = mkData[j][2]; // Column C (zero-based index 2) in MK sheet (adjust if needed)
    
    if (mkPartNumber && partCountMap[mkPartNumber] !== undefined) {
      // Update the part_count column in MK sheet (assuming it's column P, index 15)
      selectedMkSheet.getRange(j + 1, 14).setValue(partCountMap[mkPartNumber]); // +1 because the range is 1-based
    }
  }

  Logger.log("Part counts updated for MK sheet: " + selectedMkSheet.getName());
}





function syncMoveCheckboxes(sheetName) {
  // get sheet and metadata
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
  if (!sheet) {
    Logger.log("Sheet not found: " + sheetName);
    return;
  }
  
  // get header values from the first row
  var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  var ufpColIndex = headers.indexOf("Used for Production") + 1;  // 1-based index
  var moveColIndex = headers.indexOf("Move") + 1;
  
  if (ufpColIndex === 0 || moveColIndex === 0) {
    Logger.log("Required columns not found.");
    return;
  }
  
  // find the last row with data (starting at row 2, since row 1 is header)
  var lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  
  // get the entire UFP range (from row 2 to last row)
  var ufpRange = sheet.getRange(2, ufpColIndex, lastRow - 1, 1);
  var ufpValues = ufpRange.getValues();
  
  // get the entire Move range (from row 2 to last row)
  var moveRange = sheet.getRange(2, moveColIndex, lastRow - 1, 1);
  
  // make an array for new Move values
  var newMoveValues = [];
  
  // loop through each UFP cell
  for (var i = 0; i < ufpValues.length; i++) {
    var cellValue = ufpValues[i][0];
    // checkbox logic.
    if (cellValue && cellValue.toString().trim() !== "") {
      newMoveValues.push([true]);  // checked
    } else {
      newMoveValues.push([""]);    // clear the cell
    }
  }
  
  // set the new Move values back to the sheet
  moveRange.setValues(newMoveValues);
  
  // mini check
  // reapply checkbox data validation to the entire Move range if needed:
  var rule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
  moveRange.setDataValidation(rule);
  
  Logger.log("Sync complete on sheet: " + sheetName);

  // correctly check/uncheck the first selected cell if it exists
  if (firstAffectedRow !== null) {
    var firstUfpCell = sheet.getRange(firstAffectedRow, ufpColIndex);
    var firstMoveCell = sheet.getRange(firstAffectedRow, moveColIndex);
    var firstUfpValue = firstUfpCell.getValue();

    firstMoveCell.setValue(firstUfpValue && firstUfpValue.toString().trim() !== "" ? true : "");
    firstMoveCell.setDataValidation(rule);
    
    Logger.log("Rechecked first affected row: " + firstAffectedRow);
  }
}


function onEdit(e) {
  if (!e) return; 

  var range = e.range;
  var sheet = range.getSheet();
  var sheetName = sheet.getName();

  if (sheetName.startsWith('MK')) {
    var sheet = e.source.getActiveSheet();

    syncMoveCheckboxes(sheetName);
    var col = range.getColumn();
    var row = range.getRow();
    
    // get header row values to find column indexes
    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]; 
    var usedForProductionCol = headers.indexOf("Used for Production") + 1; 
    var moveCol = headers.indexOf("Move") + 1; 

    
    
    // only act if the edited cell is in the UFP column (not header)
    if (col === usedForProductionCol && row > 1) {
      var uopCell = sheet.getRange(row, usedForProductionCol);
      var moveCell = sheet.getRange(row, moveCol);
      
      // clear the UOP cell if it contains any value
      if (uopCell.getValue() !== "") {
        uopCell.clearContent();
      }
      
      // ensure the Move cell has checkbox validation
      var dv = moveCell.getDataValidation();
      if (!dv || dv.getCriteriaType() !== SpreadsheetApp.DataValidationCriteria.CHECKBOX) {
        var rule = SpreadsheetApp.newDataValidation().requireCheckbox().build();
        moveCell.setDataValidation(rule);
      }
      
      // Checks box only if the user has just entered a value in UFP
      // UFP was cleared above, so check if the edit event has a new value
      var newValue = e.value; // This is the new value entered (if any)
      if (newValue && newValue.toString().trim() !== "") {
        // set UOP to new value and check the checkbox
        uopCell.setValue(newValue);
        moveCell.setValue(true);
      } else {
        // otherwise, leave UFP empty and uncheck the checkbox
        moveCell.setValue(false);
      }
    }
  }

    if (sheetName === 'updated_quantities') {
        var col = range.getColumn();
        var row = range.getRow();

        if (col === 4 && row > 1) {
            var inventorySheet = sheet;
            var inventoryPartNumber = inventorySheet.getRange(row, 1).getValue();
            var inventoryLotNumber = inventorySheet.getRange(row, 10).getValue();
            var inventoryLocation = inventorySheet.getRange(row, 3).getValue();
            var inventoryQty = inventorySheet.getRange(row, 4).getValue();
            var inventoryPartUOM = inventorySheet.getRange(row, 5).getValue();
            var inventoryDescription = inventorySheet.getRange(row, 2).getValue();
            var inventoryTotalQty = inventorySheet.getRange(row, 12).getValue();
            var inventoryVendorUOM = inventorySheet.getRange(row, 14).getValue();

            var key = inventoryPartNumber + '-' + inventoryLotNumber + '-' + inventoryDescription;
            var masterDataSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('master_data');
            var masterDataRange = masterDataSheet.getDataRange();
            var masterDataValues = masterDataRange.getValues();

            var masterRow = masterDataValues.find(function(row) {
                return row[4] === inventoryPartNumber && row[2] === inventoryLotNumber;
            });

            if (masterRow) {
                masterRow[18] = inventoryQty;
                masterRow[1] = inventoryLocation;

                var newQtyCase = (inventoryVendorUOM && inventoryQty) ? (inventoryQty / inventoryVendorUOM) : null;
                masterRow[19] = newQtyCase;

                var newTotalCase = (inventoryVendorUOM && inventoryTotalQty) ? (inventoryTotalQty / inventoryVendorUOM) : null;
                masterRow[21] = newTotalCase;

                //added more over here
                var casesNeeded = (masterVendorUOM && inventoryTotalQty) ? (inventoryTotalQty / masterVendorUOM) : '';
                var casesRounded = (casesNeeded !== '') ? Math.round(casesNeeded) : '';

                masterRow[9] = casesNeeded; // Column J (index 9)
                masterRow[10] = casesRounded; // Column K (index 10)    

                masterDataRange.setValues(masterDataValues);
                formatMasterData();
            } else {
                var newRow = [
                    '', // Master MO Number
                    inventoryLocation,
                    inventoryLotNumber,
                    inventoryPartNumber,
                    inventoryPartUOM,
                    '', // Master Vendor UOM
                    '', // Master Part Count
                    inventoryQty,
                    '', // New Qty Case
                    inventoryTotalQty,
                    '' // New Total Case
                ];

                var lastRow = masterDataSheet.getLastRow() + 1;
                masterDataSheet.getRange(lastRow, 1, 1, newRow.length).setValues([newRow]);
            }
        }
    }
}


/** Sort the Master Data Tab */
function formatMasterData() {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var masterDataSheet = spreadsheet.getSheetByName("master_data");
    var range = masterDataSheet.getDataRange();
    var values = range.getValues();

    // Keep the header row
    var headerRow = values.shift();

    // Sort the data rows
    values.sort(function(a, b) {
        // First, sort by MO number (column A) in descending order
        if (a[0] > b[0]) {
            return -1;
        } else if (a[0] < b[0]) {
            return 1;
        } else {
            // If MO Numbers are equal, sort by Part Number (column E)
            if (a[4] < b[4]) {
                return -1;
            } else if (a[4] > b[4]) {
                return 1;
            } else {
                // If Part Numbers are also equal, handle sorting by Part Count and Lot Code
                var partCountA = a[15];
                var partCountB = b[15];

                // Handle PartCount 1 separately
                if (partCountA === 1 && partCountB !== 1) {
                    return -1;
                } else if (partCountA !== 1 && partCountB === 1) {
                    return 1;
                } else if (partCountA === null && partCountB !== null) {
                    return -1;
                } else if (partCountA !== null && partCountB === null) {
                    return 1;
                } else if (partCountA === null && partCountB === null) {
                    // If both are null, sort by Lot Code (column C) with "XXX" or "xxx" coming first
                    var lotA = a[2] ? a[2].toString().toLowerCase() : '';
                    var lotB = b[2] ? b[2].toString().toLowerCase() : '';
                    
                    var isALotX = lotA.startsWith('xxx') || lotA.startsWith('xxx');
                    var isBLotX = lotB.startsWith('xxx') || lotB.startsWith('xxx');
                    
                    if (isALotX && !isBLotX) {
                        return -1;
                    } else if (!isALotX && isBLotX) {
                        return 1;
                    } else {
                        // If both Lot Codes are either X-prefixed or not, compare them lexically
                        if (lotA < lotB) {
                            return -1;
                        } else if (lotA > lotB) {
                            return 1;
                        } else {
                            // If Lot Codes are also equal, sort by Expiration Date (column D)
                            if (a[3] < b[3]) {
                                return -1;
                            } else if (a[3] > b[3]) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    }
                } else {
                    // Sort by Part Count numerically if Part Counts are not null
                    partCountA = partCountA === null ? Infinity : partCountA;
                    partCountB = partCountB === null ? Infinity : partCountB;
                    if (partCountA < partCountB) {
                        return -1;
                    } else if (partCountA > partCountB) {
                        return 1;
                    } else {
                        // If Part Counts are also equal, sort by Lot Code (column C)
                        var lotA = a[2] ? a[2].toString().toLowerCase() : '';
                        var lotB = b[2] ? b[2].toString().toLowerCase() : '';
                        
                        // Sort "XXX" or "xxx" first
                        var isALotX = lotA.startsWith('xxx');
                        var isBLotX = lotB.startsWith('xxx');
                        if (isALotX && !isBLotX) {
                            return -1;
                        } else if (!isALotX && isBLotX) {
                            return 1;
                        } else {
                            // Compare lexically
                            if (lotA < lotB) {
                                return -1;
                            } else if (lotA > lotB) {
                                return 1;
                            } else {
                                // If Lot Codes are also equal, sort by Expiration Date (column D)
                                if (a[3] < b[3]) {
                                    return -1;
                                } else if (a[3] > b[3]) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    });

    // Combine the header row back with the sorted data
    values.unshift(headerRow);

    // Write the sorted data back to the sheet
    masterDataSheet.getRange(1, 1, values.length, values[0].length).setValues(values);

}


function getMksheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  for (const sheet of sheets) {
    const name = sheet.getName();
    if (name.startsWith("MK ")) {
      return sheet;
    }
  }

  return null; // No matching sheet found
}

// new move inventory
// function moveInventory() {
//   const ss = SpreadsheetApp.getActiveSpreadsheet();
//   const mksheet = findActiveSheetWithCheckedCheckbox();
//   const masterSheet = ss.getSheetByName('master_data');
//   const importSheet = ss.getSheetByName('import_template_ab');
//   let insertedRows = [];

//   if (!mksheet || !masterSheet || !importSheet) {
//     Logger.log("âŒ One or more required sheets not found.");
//     return;
//   }

//   const moIndex = 1;
//   const beginLocationIndex = 2;
//   const partNumberIndex = 3;
//   const vendorUOMIndex = 7;
//   const productionIndex = 11;
//   const moveBoxIndex = 13;
//   const partCountIndex = 14;
//   const shortQtyIndex = 15;
//   const onHandIndex = 17;

//   const startRow = 2;
//   const endRow = mksheet.getLastRow();
//   const transferRows = [];
//   const remainingNeedMap = {};

//   for (let row = endRow; row >= startRow; row--) {
//     const moNumber = mksheet.getRange(row, moIndex).getValue();
//     const partNumber = mksheet.getRange(row, partNumberIndex).getValue();
//     const beginLocation = mksheet.getRange(row, beginLocationIndex).getValue();
//     const vendorUOM = Number(mksheet.getRange(row, vendorUOMIndex).getValue());
//     const production = Number(mksheet.getRange(row, productionIndex).getValue());
//     const moveBox = mksheet.getRange(row, moveBoxIndex).getValue();
//     const partCount = Number(mksheet.getRange(row, partCountIndex).getValue());
//     const onHand = Number(mksheet.getRange(row, onHandIndex).getValue());

//     const key = `${moNumber}_${partNumber}`;
//     if (!remainingNeedMap[key]) {
//       remainingNeedMap[key] = vendorUOM * production;
//     }

//     let stillNeeded = remainingNeedMap[key];
//     let calculatedShortQty = Math.max(stillNeeded - onHand, 0);
//     let usedInThisRow = Math.min(onHand, stillNeeded);

//     remainingNeedMap[key] -= usedInThisRow;
//     if (remainingNeedMap[key] < 0) remainingNeedMap[key] = 0;

//     // const usedInProd = vendorUOM * production;
//     // const calculatedShortQty = usedInProd - onHand;

//     // mksheet.getRange(row, shortQtyIndex).setValue(calculatedShortQty);
//     // Logger.log(`ðŸ” Row ${row}: usedInProd=${usedInProd}, onHand=${onHand}, calculated shortQty=${calculatedShortQty}`);
//     mksheet.getRange(row, shortQtyIndex).setValue(calculatedShortQty);
//     Logger.log(`ðŸ” Row ${row}: needed=${stillNeeded}, onHand=${onHand}, shortQty=${calculatedShortQty}`);


//     // Run cascading if needed
//     if (calculatedShortQty > 0) {
//       Logger.log(`â› Cascading triggered for: ${partNumber}`);
//       const inserted = shortQuantities(row, moNumber, partNumber, partCount, calculatedShortQty);
//       if (Array.isArray(inserted)) {
//         insertedRows = insertedRows.concat(inserted);
//         Logger.log(`ðŸ“¥ Added ${inserted.length} cascading rows for transfer.`);
//       }
//     }

//     // Transfer original row if applicable
//     if (usedInThisRow  > 0 || partCount > 1) {
//       transferRows.push([
//         partNumber,
//         beginLocation,
//         usedInThisRow,
//         'Atom Banana_Meal Kit-Picking',
//         '',
//         '',
//         '',
//         partCount.toString()
//       ]);
//       Logger.log(`âœ… Main Row ${row} queued for transfer.`);
//       mksheet.getRange(row, moveBoxIndex).setValue(false);
//     }
//   }

//   // âœ… Process inserted cascading rows properly
//   const groupedByPart = {};
//   insertedRows.forEach(row => {
//     const key = row[1]; // partNumber
//     if (!groupedByPart[key]) groupedByPart[key] = [];
//     groupedByPart[key].push(row);
//   });

//   Object.entries(groupedByPart).forEach(([partNumber, rows]) => {
//     let remainingShort = rows[0][4]; // take initial shortage only once

//     for (const row of rows) {
//       const [iRow, iPartNumber, iPartCount, iBeginLocation] = row;
//       const onHand = Number(mksheet.getRange(iRow, onHandIndex).getValue());

//       if (remainingShort <= 0) break; // ðŸ’¥ Stop after shortage is resolved

//       const usedQty = Math.min(onHand, remainingShort);
//       const newShortQty = Math.max(remainingShort - onHand, 0);

//       mksheet.getRange(iRow, shortQtyIndex).setValue(newShortQty);
//       mksheet.getRange(iRow, moveBoxIndex).setValue(false);

//       transferRows.push([
//         iPartNumber,
//         iBeginLocation,
//         usedQty,
//         'Atom Banana_Meal Kit-Picking',
//         '',
//         '',
//         '',
//         iPartCount.toString()
//       ]);

//       Logger.log(`ðŸ†• Cascaded Row ${iRow} (${iPartNumber}) queued with qty = ${usedQty}`);

//       remainingShort = newShortQty;
//     }
//     });

//   transferData(transferRows);
// }

function moveInventory() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mksheet = findActiveSheetWithCheckedCheckbox();
  const masterSheet = ss.getSheetByName('master_data');
  const importSheet = ss.getSheetByName('import_template_ab');
  let insertedRows = [];
  if (!mksheet || !masterSheet || !importSheet) {
    Logger.log(":x: One or more required sheets not found.");
    return;
  }
  const moIndex = 1;
  const beginLocationIndex = 2;
  const partNumberIndex = 3;
  const vendorUOMIndex = 7;
  const productionIndex = 11;
  const moveBoxIndex = 13;
  const partCountIndex = 14;
  const shortQtyIndex = 15;
  const onHandIndex = 17;
  const startRow = 2;
  const endRow = mksheet.getLastRow();
  const transferRows = [];
  const remainingNeedMap = {};
  // First pass: bottom-up
  for (let row = endRow; row >= startRow; row--) {
    const moNumber = mksheet.getRange(row, moIndex).getValue();
    const partNumber = mksheet.getRange(row, partNumberIndex).getValue();
    const beginLocation = mksheet.getRange(row, beginLocationIndex).getValue();
    const vendorUOM = Number(mksheet.getRange(row, vendorUOMIndex).getValue());
    let productionRaw = mksheet.getRange(row, productionIndex).getValue();
    const production = Number(productionRaw);
    if (isNaN(production)) {
      Logger.log(`:warning: Row ${row} has invalid production value: "${productionRaw}"`);
      continue;
    }
    const moveBox = mksheet.getRange(row, moveBoxIndex).getValue();
    const partCount = Number(mksheet.getRange(row, partCountIndex).getValue());
    const onHand = Number(mksheet.getRange(row, onHandIndex).getValue());
    const key = `${moNumber}_${partNumber}`;
    if (!remainingNeedMap[key]) {
      remainingNeedMap[key] = vendorUOM * production;
    }
    let stillNeeded = remainingNeedMap[key];
    const usedInThisRow = Math.min(onHand, stillNeeded);
    const calculatedShortQty = stillNeeded - usedInThisRow;
    remainingNeedMap[key] = Math.max(calculatedShortQty, 0);
    mksheet.getRange(row, shortQtyIndex).setValue(calculatedShortQty);
    Logger.log(`:mag: Row ${row}: needed=${stillNeeded}, onHand=${onHand}, shortQty=${calculatedShortQty}`);
    if (calculatedShortQty > 0) {
      Logger.log(`:pick: Cascading triggered for: ${partNumber}`);
      const inserted = shortQuantities(row, moNumber, partNumber, partCount, calculatedShortQty);
      if (Array.isArray(inserted)) {
        insertedRows = insertedRows.concat(inserted);
        Logger.log(`:inbox_tray: Added ${inserted.length} cascading rows for transfer.`);
      }
    }
    if (usedInThisRow > 0 || partCount > 1) {
      transferRows.push([
        partNumber,
        beginLocation,
        usedInThisRow,
        'Atom Banana_Meal Kit-Picking',
        '',
        '',
        '',
        partCount.toString()
      ]);
      Logger.log(`:white_check_mark: Main Row ${row} queued for transfer.`);
      mksheet.getRange(row, moveBoxIndex).setValue(false);
    }
  }
  // Keep cascading until all shortages are resolved
  let stillShort = true;
  while (stillShort) {
    stillShort = false;
    let newInsertedRows = [];
    for (let row = endRow; row >= startRow; row--) {
      const shortQty = Number(mksheet.getRange(row, shortQtyIndex).getValue());
      if (shortQty > 0) {
        const moNumber = mksheet.getRange(row, moIndex).getValue();
        const partNumber = mksheet.getRange(row, partNumberIndex).getValue();
        const beginLocation = mksheet.getRange(row, beginLocationIndex).getValue();
        const partCount = Number(mksheet.getRange(row, partCountIndex).getValue());
        Logger.log(`:repeat: Continuing cascade for row ${row} (${partNumber}) with shortQty ${shortQty}`);
        const inserted = shortQuantities(row, moNumber, partNumber, partCount, shortQty);
        if (Array.isArray(inserted) && inserted.length > 0) {
          newInsertedRows = newInsertedRows.concat(inserted);
          stillShort = true;
        }
      }
    }
    insertedRows = insertedRows.concat(newInsertedRows);
  }
  // Final pass: top-down processing of insertedRows
  insertedRows.sort((a, b) => a[0] - b[0]);
  let lotIndexMap = {}; // Track lot numbers per part to assign correct partCount
  insertedRows.forEach((ins) => {
    if (ins.length >= 6) {
      const [iRow, iPartNumber, , iBeginLocation, originalShortQty] = ins;
      const onHand = Number(mksheet.getRange(iRow, onHandIndex).getValue());
      const vendorUOM = Number(mksheet.getRange(iRow, vendorUOMIndex).getValue());
      const usedFromThisRow = Math.min(onHand, originalShortQty);
      const newShortQty = originalShortQty - usedFromThisRow;
      // :white_check_mark: Round to two decimals
      const usedInProd = Math.round((usedFromThisRow / vendorUOM) * 100) / 100;
      mksheet.getRange(iRow, productionIndex).setValue(usedInProd);
      mksheet.getRange(iRow, shortQtyIndex).setValue(newShortQty);
      // :white_check_mark: Assign incremented lot count (partCount)
      if (!lotIndexMap[iPartNumber]) lotIndexMap[iPartNumber] = 2;
      const partCount = lotIndexMap[iPartNumber]++;
      if (usedFromThisRow > 0) {
        transferRows.push([
          iPartNumber,
          iBeginLocation,
          usedFromThisRow,
          'Atom Banana_Meal Kit-Picking',
          '',
          '',
          '',
          partCount.toString()
        ]);
      }
      Logger.log(`:new: Cascaded Row ${iRow} used=${usedFromThisRow}, shortQty=${newShortQty}, usedInProd=${usedInProd}, partCount=${partCount}`);
    } else {
      Logger.log(`:warning: Skipped malformed cascading row: ${JSON.stringify(ins)}`);
    }
  });
  // :white_check_mark: Add all transfer rows to the master
  transferData(transferRows);
}





/** Quantities are short */
function shortQuantities(j, moNumber, partNumber, partCount, shortQty) {
  const mksheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const onHandIndex = 13; // âœ… Adjust if "on hand" column is different
  Logger.log('ðŸ§® Short amount: ' + shortQty);

  // âœ… Write initial shortQty to main row
  mksheet.getRange(j, 15).setValue(shortQty);

  // âœ… Insert rows from master
  const inserted = copyMasterDataRowToActiveSheet(j, moNumber, partNumber, partCount);

  let remainingShort = shortQty;
  const result = [];

  Logger.log('ðŸ“‹ Inserted rows from master data:');

  inserted.forEach(([iRow, iPartNumber, iPartCount, iBeginLocation], idx) => {
    const onHand = Number(mksheet.getRange(iRow, onHandIndex).getValue());
    const used = Math.min(remainingShort, onHand);
    const thisShortQty = remainingShort;

    remainingShort -= used;

    const row = [iRow, iPartNumber, iPartCount, iBeginLocation, thisShortQty, 0];
    result.push(row);

    Logger.log(`âž¡ï¸ Mapped row: [${iRow},"${iPartNumber}",${iPartCount},"${iBeginLocation}",${thisShortQty},0]`);
  });

  Logger.log('âœ… Final result from shortQuantities:');
  result.forEach((r, i) => Logger.log(`  ${i}: ${JSON.stringify(r)}`));

  return result;
}





/** COPY DATA FROM MASTER TAB TO ACTIVE SHEET */
function copyMasterDataRowToActiveSheet(j, moNumber, partNumber, partCount) {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const masterDataSheet = spreadsheet.getSheetByName("master_data");
    const activeSheet = findActiveSheetWithCheckedCheckbox();

    const masterDataValues = masterDataSheet.getDataRange().getValues();
    const matchingRows = [];

    const originalRow = j; // Remember the original row to update later
    let lastPartCount = parseInt(partCount); // Start from the existing part count

    // Filter master data for matching partNumber and increasing partCount
    for (let row = 1; row < masterDataValues.length; row++) {
      const masterDataRow = masterDataValues[row];
      const masterPart = masterDataRow[4];
      const masterPartCount = masterDataRow[15];

      if (masterPart === partNumber && parseInt(masterPartCount) > parseInt(partCount)) {
        matchingRows.push({ index: row, count: parseInt(masterPartCount), values: masterDataRow });
      }
    }

    // Sort by partCount ASC
    matchingRows.sort((a, b) => a.count - b.count);

    if (matchingRows.length === 0) {
      Logger.log("âš  No matching rows found for part: " + partNumber);
      activeSheet.getRange(j, 1, 1, activeSheet.getLastColumn()).setBackground("#fce38a");
      return [];
    }

    let remainingShortQty = activeSheet.getRange(j, 15).getValue(); // qty_short column
    Logger.log("â› Starting cascading insert for: " + partNumber + " | Short Qty: " + remainingShortQty);

    const insertedRows = [];

    for (let i = 0; i < matchingRows.length && remainingShortQty > 0; i++) {
      const rowData = matchingRows[i].values;

      const columnsToCopy = [1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rowToInsert = columnsToCopy.map(col => rowData[col - 1]);

      activeSheet.insertRowAfter(j);
      activeSheet.getRange(j + 1, 1, 1, rowToInsert.length).setValues([rowToInsert]);

      lastPartCount += 1; // Increment from original
      activeSheet.getRange(j + 1, 14).setValue(lastPartCount); // Column 14 is Part Count

      const newOnHand = rowToInsert[16]; // column 19 (0-based)
      const diff = remainingShortQty - newOnHand;
      const shortQtyForRow = Math.max(diff, 0);

      activeSheet.getRange(j + 1, 15).setValue(shortQtyForRow); // qty_short
      activeSheet.getRange(j + 1, 13).setValue(true); // move checkbox

      Logger.log("ðŸ“¦ Inserted row at " + (j + 1) + " with partCount: " + lastPartCount);

      insertedRows.push([
        j + 1,
        partNumber,
        lastPartCount,
        rowToInsert[1], // beginLocation
        newOnHand,
        0 // assume usedInProd = 0 for cascading rows
      ]);

      if (diff > 0) {
        remainingShortQty = diff;
        j++; // move insert pointer down
      } else {
        remainingShortQty = 0;
        break;
      }
    }

    // âœ… Mark original row as resolved if shortage fulfilled
    if (remainingShortQty <= 0 && insertedRows.length > 0) {
      const totalInsertedQty = insertedRows.reduce((sum, row) => sum + Number(row[4]), 0); // sum of onHand
      activeSheet.getRange(originalRow, 14).setValue(partCount); // restore original part count
      activeSheet.getRange(originalRow, 15).setValue(0); // clear qty_short
    }

    if (remainingShortQty > 0) {
      Logger.log("Still short after insert for: " + partNumber + " | Remaining Short: " + remainingShortQty);
      stillShort(j + 1, moNumber, partNumber, partCount);
    } else {
      Logger.log("Shortage resolved for: " + partNumber);
    }

    return insertedRows;

  } catch (err) {
    Logger.log("âŒ Error in copyMasterDataRowToActiveSheet: " + err.message);
    return [];
  }
}





/** Quantities still short */
function stillShort(nextRow, moNumber, partNumber, initialPartCount) {
  try {
    var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    var masterDataSheet = spreadsheet.getSheetByName("master_data");
    var activeSheet = findActiveSheetWithCheckedCheckbox();
    initialPartCount = Number(initialPartCount)
    var currentActiveRow = nextRow + 1;
    var nextPartCount = initialPartCount + 1;
    var partCount = activeSheet.getRange(nextRow, 14).getValue();
    var difference = Infinity;
    var processedParts = {}; // Track processed parts
    var repeatLoop = false;
 //   Logger.log("searching master data");

    SpreadsheetApp.flush();

    // Find the matching row in master_data
    var lastRowMasterData = masterDataSheet.getLastRow();

    for (var row = 2; row <= lastRowMasterData; row++) {
      Logger.log("running stillshort...");
      var masterDataMoNumber = masterDataSheet.getRange(row, 1).getValue();
      var masterDataPartNumber = masterDataSheet.getRange(row, 5).getValue();
      var masterDataPartCount = masterDataSheet.getRange(row, 16).getValue();
        if (repeatLoop === false) { 
          var newPartCount = partCount +1;
        } else{
          var newPartCount = initialPartCount +1
        }      

      // Check for a match based on MO number, part number, and part count
      if (masterDataMoNumber === moNumber && masterDataPartNumber === partNumber && masterDataPartCount === newPartCount) {
      //  Logger.log("Found matching part number in master_data tab: " + masterDataPartNumber + ", " + masterDataPartCount);

        // Track processed partNumber and partCount combination
        var key = masterDataPartNumber + '-' + masterDataPartCount;
        if (processedParts[key]) {
          Logger.log("Part number and part count already processed: " + key);
          continue;
        }

        activeSheet.insertRowAfter(nextRow);

        var columnsToCopy = [1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];

        var masterDataRowValues = columnsToCopy.map(function (columnIndex) {
          return masterDataSheet.getRange(row, columnIndex).getValue();
        });

        // Find the current row in the active sheet based on MO number, part number, and part count
        var lastRowActiveSheet = activeSheet.getLastRow();
        var maxRow = 300; // Limit the number of rows to search
        var foundRow = false;

        while (currentActiveRow <= maxRow) {
            if (activeSheet.getRange(currentActiveRow, 1).getValue() === "") {
              foundRow = true;
              break;
            }
            currentActiveRow++;
          }
          if (!foundRow) {
         //   Logger.log("No available blank rows found within the first " + maxRow + " rows.");
            return; // Exit the function or handle the situation as needed
          }
        // Paste the master_data row values into the new blank row in the active sheet
        Logger.log("ðŸ“¦ Inserting (stillShort) at row " + currentActiveRow + " with partCount: " + masterDataRowValues[13]);
        activeSheet.getRange(currentActiveRow, 1, 1, masterDataRowValues.length).setValues([masterDataRowValues]);

        // Calculate the difference
        var newPartAvailQtyIndex = 17;
        var newPartAvailQty = activeSheet.getRange(currentActiveRow, newPartAvailQtyIndex).getValue();
        var shortAboveQty = activeSheet.getRange(currentActiveRow - 1, 15).getValue();
        var difference = shortAboveQty - newPartAvailQty;
        var newPartCount = activeSheet.getRange(currentActiveRow, 14).getValue();

        // Set the value of the "qty_short" column in the new active row
        activeSheet.getRange(currentActiveRow, 15).setValue(difference);
    //    Logger.log('active row part count is:' + newPartCount);

        // Set the move box to true
        activeSheet.getRange(currentActiveRow, 13).setValue(true);

        // Update initialPartCount if necessary
        initialPartCount = newPartCount;
        nextRow = currentActiveRow;
        // Logger.log('initial part should be:' + initialPartCount);
        // Logger.log("current active row should be: " + nextRow);


        // Mark the part number as processed
        processedParts[partNumber] = true;

        // Check if the difference is less than 0, break the loop
        if (difference <= 0) {
          moveInventory(); // Move inventory even if no match is found
          return;
        } else {
          activeSheet.getRange(currentActiveRow, activeSheet.getLastColumn()).setBackgroundColor('#FFEB3B'); // Change color as needed
          repeatLoop = true;
        }
      }
    }

  } catch (error) {
   // Logger.log("Error in stillShort: " + error.message);
  }
}






/** Transfer the data to the template */
// function transferData() {
//   var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
//   var activeSheet = findActiveSheetWithCheckedCheckbox();
//   var importTemplate = spreadsheet.getSheetByName('import_template_ab');
//   var shouldMoveData = false;
//   var sourceData = activeSheet.getDataRange().getValues();
//   Logger.log("sourceData.length: " + sourceData.length);

//   // 0-based index
//   var beginIndex = 1; // column B
//   var partNumberIndex = 2; // column C
//   var pickQtyIndex = 4; // column E  
//   var vendorUOMIndex = 6; // column G  
//   var productionIndex = 10; // column K
//   var moveBoxIndex = 12; // column M  
//   var partCountIndex = 13; // column N
//   var shortQtyIndex = 14; // column O
//   var onHandIndex = 16; // column Q

//   var valuesToPaste = [];

//   for (var i = sourceData.length - 1; i >= 1; i--) {
//     var begin_location = sourceData[i][beginIndex];
//     var partNumber = sourceData[i][partNumberIndex];
//     var pickQty = sourceData[i][pickQtyIndex];
//     var vendorUOM = sourceData[i][vendorUOMIndex];
//     var production = sourceData[i][productionIndex];
//     var moveBox = sourceData[i][moveBoxIndex];
//     var partCounts = parseInt(sourceData[i][partCountIndex]);
//     var onHand = sourceData[i][onHandIndex];

//     // Normalize shortDiff and prevDiff as numbers
//     var rawShort = sourceData[i][shortQtyIndex];
//     var shortDiff = rawShort === "" ? "" : Number(rawShort);

//     var rawPrev = sourceData[i - 1] ? sourceData[i - 1][shortQtyIndex] : "";
//     var prevDiff = rawPrev === "" ? "" : Number(rawPrev);

//     if (moveBox === true) {
//       Logger.log(`Row ${i + 1} - Part: ${partNumber}, shortDiff: ${shortDiff}, prevDiff: ${prevDiff}, onHand: ${onHand}, partCounts: ${partCounts}`);

//       let quantities;

//       if (partCounts === 1 && shortDiff === "") {
//         // Case 1: Fully available inventory
//         quantities = (Number(vendorUOM) * Number(production)).toFixed(2);
//         shouldMoveData = true;
//         Logger.log(`${partNumber}: Case 1 - Full stock, using calculated qty = ${quantities}`);
//       } else if (shortDiff >= 0) {
//         // Case 2: Insufficient inventory, use all onHand
//         quantities = onHand;
//         shouldMoveData = true;
//         Logger.log(`${partNumber}: Case 2 - Shortage, using onHand qty = ${quantities}`);
//       } else if (shortDiff < 0) {
//         // Case 3: Last of split batch, use previous leftover
//         quantities = prevDiff;
//         shouldMoveData = true;
//         Logger.log(`${partNumber}: Case 3 - Final split part, using prevDiff = ${quantities}`);
//       }

//       var end_location = 'Atom Banana_Meal Kit-Picking';
//       var notes = "";
//       var exp_date = "";
//       var lot_number = "";
//       valuesToPaste.push([partNumber, begin_location, quantities, end_location, notes, lot_number, exp_date, partCounts]);
//     }
//   }

//   if (valuesToPaste.length > 0) {
//     var targetRow = 2;
//     importTemplate.getRange(targetRow, 1, valuesToPaste.length, valuesToPaste[0].length).setValues(valuesToPaste);
//     Logger.log('Data copied successfully!');
//   } else {
//     Logger.log('No data to copy.');
//   }

//   // Reset move boxes if anything was moved
//   if (shouldMoveData) {
//     for (var i = sourceData.length - 1; i >= 1; i--) {
//       activeSheet.getRange(i + 1, moveBoxIndex + 1).setValue(false);
//     }
//     setFormulaForColumn();
//   }
//}

//new transfer data
function transferData(transferRows) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const targetSheet = ss.getSheetByName("import_template_ab");

  if (!targetSheet) {
    Logger.log("âŒ Target sheet 'import_template_ab' not found.");
    return;
  }

  if (transferRows.length === 0) {
    Logger.log("âš ï¸ No data to transfer.");
    return;
  }

  //const startRow = targetSheet.getLastRow() + 1;
  targetSheet.getRange('A2:H').clearContent();
  const startRow = 2
  targetSheet.getRange(startRow, 1, transferRows.length, transferRows[0].length).setValues(transferRows);

  Logger.log(`âœ… Transferred ${transferRows.length} rows to 'import_template_ab'.`);

  SpreadsheetApp.flush();
  setFormulaForColumn(); // Call to fill Lot and Exp formulas

  const lastRow = targetSheet.getLastRow();
  if (lastRow > 2) {
    targetSheet.getRange(2, 1, lastRow - 1, 8).sort([
      { column: 1, ascending: true }, // Part Number
      { column: 8, ascending: true }  // Part Count
    ]);
    Logger.log("ðŸ”ƒ Sorted import_template_ab by Part Number and Part Count.");
  }
}

// function transferRows2() {
//   const ss = SpreadsheetApp.getActiveSpreadsheet();
//   const mksheet = findActiveSheetWithCheckedCheckbox();
//   const importSheet = ss.getSheetByName('import_template_ab');

//   if (!mksheet || !importSheet) {
//     Logger.log("âŒ Required sheet(s) not found.");
//     return;
//   }

//   const partNumberIndex = 3;
//   const beginLocationIndex = 2;
//   const partCountIndex = 14;

//   const startRow = 2;
//   const endRow = mksheet.getLastRow();
//   const rowsToTransfer = [];

//   for (let row = startRow; row <= endRow; row++) {
//     const partCount = Number(mksheet.getRange(row, partCountIndex).getValue());
//     if (partCount > 1) {
//       const partNumber = mksheet.getRange(row, partNumberIndex).getValue();
//       const beginLocation = mksheet.getRange(row, beginLocationIndex).getValue();

//       rowsToTransfer.push([
//         partNumber,
//         beginLocation,
//         0,
//         'Atom Banana_Meal Kit-Picking',
//         '',
//         '',
//         '',
//         partCount.toString()
//       ]);
//       Logger.log(`ðŸš€ Extra partCount>1 Row ${row} (${partNumber}) queued for transfer.`);
//     }
//   }

//   if (rowsToTransfer.length === 0) {
//     Logger.log("â„¹ï¸ No extra partCount>1 rows to transfer.");
//     return;
//   }

//   // Append to import_template_ab below existing rows
//   const targetStartRow = importSheet.getLastRow() + 1;
//   importSheet.getRange(targetStartRow, 1, rowsToTransfer.length, rowsToTransfer[0].length)
//     .setValues(rowsToTransfer);

//   Logger.log(`âœ… Transferred ${rowsToTransfer.length} extra rows to 'import_template_ab'.`);

//   // Sort the import sheet by part number (column A)
//   const lastRow = importSheet.getLastRow();
//   if (lastRow > 1) {
//     importSheet.getRange(2, 1, lastRow - 1, 8).sort({ column: 1, ascending: true });
//     Logger.log("ðŸ”ƒ Sorted 'import_template_ab' by part number.");
//   }
// }










  
/** Updates the lot number and expiration date info for import template */
function setFormulaForColumn() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var targetSheet = spreadsheet.getSheetByName('import_template_ab');
  var mkSheet = findActiveSheetWithCheckedCheckbox(); // Assumes you have a way to identify mksheet dynamically

  if (!targetSheet || !mkSheet) {
    Logger.log("âŒ Required sheet(s) not found.");
    return;
  }

  var finalRow = targetSheet.getRange('A:A').getValues().flat().filter(String).length;

  var lotCodeIndex = 6;         // Column F
  var expirationDateIndex = 7;  // Column G
  var trackingRevisionIndex = 8; // Column H
  var partNumberIndex = 1;      // Column A
  var partCountIndex = 8;       // Column H (as value)
  var startRow = 2;

  var mkData = mkSheet.getDataRange().getValues();

  for (var i = startRow; i <= finalRow; i++) {
    var partNumber = targetSheet.getRange(i, partNumberIndex).getValue();
    var partCount = targetSheet.getRange(i, partCountIndex).getValue();

    // --- Column F: Lot Code Formula ---
    var lotCodeFormula = `=INDEX(master_data!C2:C, MATCH(1, (master_data!E2:E="${partNumber}") * (master_data!P2:P=${partCount}), 0))`;
    targetSheet.getRange(i, lotCodeIndex).setFormula(lotCodeFormula);

    // --- Column G: Expiration Date Formula ---
    var expDateFormula = `=INDEX(master_data!D2:D, MATCH(1, (master_data!E2:E="${partNumber}") * (master_data!P2:P=${partCount}), 0))`;
    targetSheet.getRange(i, expirationDateIndex).setFormula(expDateFormula);

    // --- Column H: Tracking Revision Logic ---
    var revisionFound = false;
    var fallbackRevision = '';

    for (var r = 1; r < mkData.length; r++) {
      var mkPartNumber = mkData[r][2];  // Column C in mksheet
      var mkPartCount = mkData[r][13];  // Column N in mksheet
      var mkShortQty = mkData[r][14];   // Column O in mksheet

      if (mkPartNumber == partNumber && mkPartCount == partCount) {
        targetSheet.getRange(i, trackingRevisionIndex).setValue(String(mkPartCount));
        revisionFound = true;
        break;
      } else if (mkPartNumber == partNumber && mkShortQty <= 0) {
        fallbackRevision = String(mkPartCount);
      }
    }

    if (!revisionFound && fallbackRevision) {
      targetSheet.getRange(i, trackingRevisionIndex).setValue(fallbackRevision);
    }
  }
}




function downloadTemplate() {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = spreadsheet.getSheetByName("import_template_ab");
  if (!sheet) {
    Logger.log("Sheet not found!");
    return;
  }
  
  // Get the data range
  var range = sheet.getRange("A1:G" + sheet.getLastRow());
  var values = range.getValues();
  
  // Convert the data to CSV format with date values as strings
  var csv = "";
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values[i].length; j++) {
      if (values[i][j] instanceof Date) {
        // Format date as string (e.g., "yyyy-MM-dd")
        values[i][j] = Utilities.formatDate(values[i][j], Session.getScriptTimeZone(), "MM/dd/yyyy");
      }
    }
    csv += values[i].join(",") + "\n";
  }
  
  // Create a Blob from the CSV data
  var blob = Utilities.newBlob(csv, 'text/csv', 'import_template_ab.csv');
  
  // Save the file to the user's Drive
  var file = DriveApp.createFile(blob);
  
  // Get the URL of the file
  var fileUrl = file.getUrl();
  
  Logger.log("CSV file created: " + fileUrl);
  
  // Create a custom dialog to prompt the user with the download link
  var html = '<html><body><a href="' + fileUrl + '" target="_blank">Click here to download the CSV file</a></body></html>';
  var ui = SpreadsheetApp.getUi();
  ui.showModalDialog(HtmlService.createHtmlOutput(html), 'Download CSV');
}


/** if you ever add new columns and need the widths for updating the initial script, comment this back in to get those values.*/
// function getColumnWidths(sheetName) {
//   var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
//   var columnCount = spreadsheet.getDataRange().getValues()[0].length;
  
//   var columnWidths = [];
//   for (var i = 1; i <= columnCount; i++) {
//     columnWidths.push(spreadsheet.getColumnWidth(i));
//   }
  
//   Logger.log('Column Widths: ' + columnWidths);
//   return columnWidths;
  
function updateUsedinProduction() {
  var ss = SpreadsheetApp.getActiveSpreadsheet(); // First Google Sheet
  var mkSheetName = mkSheet.getName();
  
  var sourceSpreadsheetId = "193VO_Anu4XGvbkNYz4u1F_DD0FU_1_e_SIYOqD6mvgQ"; // Replace with the second sheet's ID
  var sourceSpreadsheet = SpreadsheetApp.openById(sourceSpreadsheetId);
  
  var lastRow = sheet.getLastRow();
  if (lastRow < 2) return; // Exit if there's no data

  var partNumbers = sheet.getRange("C2:C" + lastRow).getValues(); // part_number column
  var dates = sheet.getRange("C2:C" + lastRow).getValues(); // Date column (must match tab names)
  var outputRange = sheet.getRange("K2:K" + lastRow); // Column K where data is written

  var outputValues = [];

  for (var i = 0; i < partNumbers.length; i++) {
    var partNumber = partNumbers[i][0];
    var date = dates[i][0];

    if (!partNumber || !date) {
      outputValues.push([""]); // Skip if data is missing
      continue;
    }

    var formattedDate = Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), "yyyy-MM-dd");
    var sourceSheetName = formattedDate; // Assuming the tab names match the date format

    var sourceSheet = sourceSpreadsheet.getSheetByName(sourceSheetName);
    if (!sourceSheet) {
      outputValues.push([""]); // Skip if no matching tab
      continue;
    }

    var sourceData = sourceSheet.getDataRange().getValues();
    var partIndex = sourceData[0].indexOf("SKU"); // Find column index of part_number
    var columnNIndex = 13; // Column N (0-based index is 13)

    if (partIndex === -1) {
      outputValues.push([""]); // Skip if part_number column isn't found
      continue;
    }

    var valueFound = false;
    for (var j = 1; j < sourceData.length; j++) { // Start at 1 to skip headers
      if (sourceData[j][partIndex] == partNumber) {
        outputValues.push([sourceData[j][columnNIndex]]);
        valueFound = true;
        break;
      }
    }

    if (!valueFound) {
      outputValues.push([""]); // No match found
    }
  }

  outputRange.setValues(outputValues);
}

